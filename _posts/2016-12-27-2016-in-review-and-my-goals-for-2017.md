---
layout: post
title: 2016 in review and my goals for 2017
---

Just like every other blog on the internets, I wanted to close out the year with some of my thoughts from this year's exeriences. I apologize in advanced since this post will be more a smothering of words than a coherent collection of thoughts. This year was special because I finished with school and joined the workforce as a full time software engineer at [Josh.ai](https://www.josh.ai/about). Let me tell you, I've been visceral about becoming the best possible programmer I can be, ever since I started programming in 2008. And even with all of my reading, all of the videos I've watched, the conferences I've attended, the internships, the contracting, the everything I've done, none of it will teach you more about being a programmer than having to sit down and program all day every day.

Being in a startup definitely amplifies everything that you need to do, seeing as there's not as many people around to get things done, and the direction you get is mostly only a suggestion, but I'd think even at an established company, you're still going to learn a lot.

Programming is a visciously deceptive field filled with more surprises than you could ever expect. By all means, writing code is an activity that I perform plenty, but not even close to being the only thing that needs to get done. Reading code takes up significantly more time. This could be my own code, or the documentation of a library that I'm trying to use, or the code of another co-worker. It changes on an hourly basis. The amount of times that I've thought, "this doesn't make any fucking sense", or "this documentation is just flat out wrong", is much too high to count. Every platform we use, every library we use, every module we wrote, all suffers from the same fate. Our technical debt is practically unmanageable, but we don't have the time to really fix anything with the patience and focus it needs.

You see, we need to optimize for the time to market, and features help sweeten the deal for customers. This is something that I've had an unruly amount of difficulty adapting to, but I'm definitely getting better at it. You see, at my previous job I worked for a government defense contractor, and while we had deadlines, they were really only there to keep some member of management happy. If goals weren't hit they'd get moved, and there wasn't really a crunch time. Everything progressed at a pace only found at the DMV. In school, assignments had mostly definitive deadlines, but the assignments were so trivial that it hardly mattered at all. I'm not trying to sound arrogant, but the honest truth was that for most of my assignments, I'd have them done in no more than a hand full of hours, if even that. Of course there were really interesting assignments like in my Operating Systems class, or my Compilers class, but this wasn't the normal case for me. My point is that the assignments were so simple that they were really just annoying more than anything. My current job is significantly less cushy, and it's been a lot better for me.

The programmer I was in June is awe-inducingly different from the programmer I am now, and I'm sure that this statement will be true once again in another 9 months. I've improved at recognizing trade-offs. I've improved at understanding design decisions. I've learned an infuriating amount about having to debug code. I've written more code in the last 9 months than I have in 4 years of college. The code itself is a lot more robust, it's more scalable, it's more modular, and it's more effective.

I've learned plenty about Android programming. I'm the only full time Android programmer at our company right now, and 9 months ago I was basically at 0 Android experience, and had barely any experience in using Java. I think my earlier comment was an understatement. I've learned a mind expanding amount about Android programming. I was tossed into having to learn Android, and it REALLY pushed my ability to learn quickly. I always told people that I was a fast learner, but now was the point where I had to prove it. I read [Android Programming: The Big Nerd Ranch Guide](https://www.bignerdranch.com/books/android-programming/), [High Performance Android Apps](http://shop.oreilly.com/product/0636920035053.do), [Efficient Android Threading](http://shop.oreilly.com/product/0636920029397.do), [RxJava for Android App Development](http://www.oreilly.com/programming/free/rxjava-for-android-app-development.csp), and even [Effective Java (2nd Edition)](https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683). I read a countless number of blog posts like the entire series of [Developing for Android by Chet Haase](https://medium.com/google-developers/developing-for-android-introduction-5345b451567c#.ihsxjqhmg) or [Grokking RxJava by Dan Lew](http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/). I've listened to every episode of the [Fragmented Podcast with Kaushik Gopal and Donn Felker](http://fragmentedpodcast.com/) as well as every episode from [Android Developers Backstage with Chet Haase and Tor Norby](http://androidbackstage.blogspot.com/). I've watched almost every episode from the [Android Developers YouTube channel](https://www.youtube.com/channel/UCVHFbqXqoYvEWM1Ddxl0QDg), and every conference talk I could ever find. I've paid for a yearly subscription to [Caster.IO](https://caster.io/) and have watched most of their lessons. Any purchases were out of my own pocket, and this only encompasses some of the resources I've used to learning Android development, which of course doesn't include anything I've obtained for dealing with other parts of our tech stack. Our iOS app had been developed over the last year while I was still in school, and we had an iPad app being developed by another person also. These two had each other to chat with about the nuances of iOS programming, whereas I didn't really have anyone to chat with. As part of developing the Android app, I learned about cocnepts like dependency injection with Dagger2. I learned about EventBuses, and process lifecycles and how the Android OS itself worked. I learned about how the render loop worked to try and stay at 60fps. I learned about characteristics of the garbage collectors of both the dalvik JVM as well as the ART JVM. I learned the entire paradigm of reactive programming and I promise you, that was not as straight forward as I had hoped. I learned about the nuances of non-explicit weak references and how fragments can hold a reference to something and cause a stupid memory leak. I learned about LeakCanary so that I could in theory have an easier time with memory leaks. I had to learn about Gradle and signing our APK for the Play Store. I learned about the black hole that is ProGuard for resource shrinking and some obfuscation. I learned about annotation processing and the insane amount of mistake prone boilerplate code I was writing. With all the code that I've written, I've deleted just as much if not more code. Did you know that a default Android application can only contain 65,535 methods? After that you'll have to read about something called MultiDex Applications. Oh, and importing the support libraries which are practically required takes up over 20,000 of those 65,535. And that's basically just one library. I have analytics and crash reporting baked in with the help of Crashlytics, and we even have continuous integration that runs all of my unit and UI tests with every commit.

There's a lot to learn about Android programming, and I'm really fucking proud of how much I've been able to pull off in such a short amount of time. The Android app was able to catch up with probably 95% of the iOS app in only 5 months, which again, I'm really fucking proud of.

Android programming isn't the only thing that I've done either. When you purchase one of our Josh.ai Home Bases, you receive both a Mac Mini, as well as an iPad to go with that. In the past, just setting up the Mac Mini with our software/other necessities could take anywhere between 4-6 hours of extremely repetitive and boring manual labor. I was able to reduce and automate 85% of it, so that now it only takes about 40 minutes to set up a single server. In fact, about 20 minutes of that is installing OS updates which I can't really reduce. (I'm already installing offline copies of the updates). At this point, I'm the only person who builds these servers to be sent out, and while I'm not going to share how many of them are out there, let's just say everyone all around is happier with how quickly we can churn these out.

I've also contributed code to our server which is in C++. I haven't buried myself in learning materials to the same extent as I have with Android programming, but I've done my fair share of learning in this regard as well. I've read the [C++ Primer](https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113) and most of both [Effective C++](https://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876) and [Effective Modern C++](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996). Also, I was originally hired for my experience and interest in machine learning and natural language processing. Much of that is still under wraps, but let's just remember that at work we're building an AI for your home. ;)

I've read bits and pieces of most of the classic books like [The Algorithm Design Manual](https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693), [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1?s=books&ie=UTF8&qid=1482900642&sr=1-1&keywords=clean+code), [Apprenticeship Patterns](https://www.amazon.com/Apprenticeship-Patterns-Guidance-Aspiring-Craftsman/dp/0596518382/ref=sr_1_1?s=books&ie=UTF8&qid=1482900669&sr=1-1&keywords=apprenticeship+patterns), [The Pragmatic Programmer](https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X/ref=sr_1_2?s=books&ie=UTF8&qid=1482900669&sr=1-2&keywords=apprenticeship+patterns), [The Mythical Man-Month](https://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959/ref=sr_1_1?s=books&ie=UTF8&qid=1482900716&sr=1-1&keywords=mythical+man+month), [The GoF Design Patterns book](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?s=books&ie=UTF8&qid=1482900744&sr=1-1&keywords=design+patterns), and many many more. I've watched conference talks from the likes of [Joe Armstrong](https://www.youtube.com/watch?v=lKXe3HUG2l4), [Rich Hickey](https://www.infoq.com/presentations/Simple-Made-Easy), and [Jessica Kerr](https://www.youtube.com/watch?v=pMGY9ViIGNU).

I look at code that I wrote 9 months ago and I'm shocked at what I thought was passable. I'm really happy to see how far I've come. Which is a great transition into what I see in my future.

I want to be a better programmer. I want to be more efficient, more focused, I want to have more impact at work, and I want to push myself and see how good of a programmer I can really become.

This coming year is going to be the real test of our company and our product. We officially launched in September of 2016, so I'm excited to see what the future has in store for us, but my growth as a programmer isn't directly tied to the success of our product and this company.

In 2017, I want to improve my knowledge on several aspects of the programming field. Firstly, I'd like to learn and understand much more about functional programming. I've been teased by it with RxJava and bits and pieces of Kotlin. There's a reason that it's growing in popularity and I want to understand what the hype is. The second topic I want to learn about is scaling heavily used systems. There's a reason that products like MapReduce were created, and reasons why Google is able to return a result in fractions of a second, despite indexing [trillions of web pages](http://venturebeat.com/2013/03/01/how-google-searches-30-trillion-web-pages-100-billion-times-a-month/). I watched a few of the talks from [@Scale](https://atscaleconference.com/) and I'm really fascinated by the topic. Next, I want to deploy the lessons I've learned from the master package of [The Effective Engineer by Edmond Lau](http://www.theeffectiveengineer.com/). Many of the lessons covered habits or techniques that I've been using for years, but there are several gems in the main book that I think will benefit me greatly. Also in 2017, I want to become more knowledgeable about the state and techniques of web programming. I admit that I've held an elitist view over web/frontend programming for far longer than I should have. Technologies like NodeJS, ReactJS, and other languages like Go and Rust have all been on my list of things I want to learn. Along with becoming web-fluent, I'd like to create some web based product that has a non-zero number of regular users. It will be a busy year, but with the completion of school, I have a lot more control over how my time is allocated, and it's just a matter of being responsible about it. I look forward to everything I will rant about in my recap of 2017.
